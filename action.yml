name: 'Wait For Response'
author: 'Shane Krueger'
branding:
    icon: 'clock'  
    color: 'blue'
description: 'Wait for response code from a URL with timeout'
inputs:
  url:
    description: 'URL to poll'
    required: false
    default: 'http://localhost/'
  responseCode:
    description: 'Response code to wait for'
    required: false
    default: '200'
  timeout:
    description: 'Timeout before giving up in ms'
    required: false
    default: '30000'
  interval:
    description: 'Interval between polling in ms'
    required: false
    default: '200'
  sleep:
    description: 'Sleep before initial request in ms'
    required: false
    default: '0'
  lookfor:
    description: 'String to look for in the body'
    required: false
    default: ''
outputs:
  result:
    description: '0 if response code returned within timeout, otherwise 1'
    value: ${{ steps.poll_windows.outputs.result || steps.poll_unix.outputs.result }}
runs:
  using: "composite"
  steps:
    - name: Poll URL using PowerShell
      id: poll_windows
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        if ([int] "${{ inputs.sleep }}" -gt 0) {
          Write-Host "Sleeping for $([int] "${{ inputs.sleep }}") ms"
          Start-Sleep -Milliseconds ${{ inputs.sleep }}
        }
        Write-Host ("Polling URL `{0}` for response code {1} for up to {2} ms at {3} ms intervals" -f "${{ inputs.url }}", "${{ inputs.responseCode }}", "${{ inputs.timeout }}", "${{ inputs.interval }}")
        if ("${{ inputs.lookfor }}" -ne "") {
          Write-Host "Looking for `${{ inputs.lookfor }}`"
        }
        $start = [DateTime]::UtcNow
        $timeoutMs = [int] "${{ inputs.timeout }}"
        $result = 1
        while ((([DateTime]::UtcNow - $start).TotalMilliseconds) -le $timeoutMs) {
          try {
            $response = Invoke-WebRequest -Uri "${{ inputs.url }}" -Method Get -UseBasicParsing -ErrorAction Stop
            $statusCode = $response.StatusCode.ToString()
            if ($statusCode -eq "${{ inputs.responseCode }}") {
              if ("${{ inputs.lookfor }}" -ne "") {
                if ($response.Content -match "${{ inputs.lookfor }}") {
                  Write-Host "Response header: $($response.Headers)"
                  Write-Host "Response body: $($response.Content)"
                  $result = 0
                  break
                }
              }
              else {
                Write-Host "Response header: $($response.Headers)"
                Write-Host "Response body: $($response.Content)"
                $result = 0
                break
              }
            }
          }
          catch {
            # Ignore errors (e.g. connection failures) and continue polling.
          }
          Start-Sleep -Milliseconds ${{ inputs.interval }}
        }
        if ($result -eq 1) {
          Write-Host "Timed out"
        }
        Write-Output "::set-output name=result::$result"
    - name: Poll URL using Bash
      id: poll_unix
      if: runner.os != 'Windows'
      shell: bash
      run: |
        if [ "${{ inputs.sleep }}" -gt "0" ]; then
          echo "Sleeping for ${{ inputs.sleep }} ms"
          sleep $(echo "${{ inputs.sleep }}" | awk '{printf "%.3f", $1/1000}')
        fi
        echo "Polling URL \`${{ inputs.url }}\` for response code ${{ inputs.responseCode }} for up to ${{ inputs.timeout }} ms at ${{ inputs.interval }} ms intervals"
        if [ -n "${{ inputs.lookfor }}" ]; then
          echo "Looking for \`${{ inputs.lookfor }}\`"
        fi
        start=$(date +%s%3N)
        timeout_ms=${{ inputs.timeout }}
        end=$((start + timeout_ms))
        result=1
        while [ $(date +%s%3N) -le $end ]; do
          # Capture headers in headers.txt and body in response_body.txt.
          curl -s -D headers.txt -o response_body.txt "${{ inputs.url }}"
          http_code=$(awk '/HTTP/{print $2}' headers.txt | tail -n 1)
          if [ "$http_code" = "${{ inputs.responseCode }}" ]; then
            if [ -n "${{ inputs.lookfor }}" ]; then
              if grep -q "${{ inputs.lookfor }}" response_body.txt; then
                echo "Response header: $(cat headers.txt)"
                echo "Response body: $(cat response_body.txt)"
                result=0
                break
              fi
            else
              echo "Response header: $(cat headers.txt)"
              echo "Response body: $(cat response_body.txt)"
              result=0
              break
            fi
          fi
          sleep $(echo "${{ inputs.interval }}" | awk '{printf "%.3f", $1/1000}')
        done
        if [ $result -eq 1 ]; then
          echo "Timed out"
        fi
        echo "::set-output name=result::$result"
